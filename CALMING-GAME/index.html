<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Calming â€” Gentle Affirmations</title>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <style>
    :root {
      --dark-color: #1a0a1a;
      --pink-glow: rgba(255, 105, 180, 0.3);
      --pink-bright: #ff69b4;
      --pink-deep: #ff1493;
    }
    /* Cross-browser reset and consistency (Edge, Chrome, Brave) */
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html {
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
      height: 100%;
      min-height: 100vh;
    }
    body {
      height: 100%;
      min-height: 100vh;
      overflow: hidden;
      font-family: "Segoe UI", "Helvetica Neue", Arial, system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      background-color: var(--dark-color);
    }
    /* Night background matching flower page */
    .night-bg {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      filter: blur(0.1vmin);
      background-image: 
        radial-gradient(ellipse at top, transparent 0%, var(--dark-color)),
        radial-gradient(ellipse at bottom, var(--dark-color), var(--pink-glow)),
        repeating-linear-gradient(220deg, rgb(20, 5, 20) 0px, rgb(20, 5, 20) 19px, transparent 19px, transparent 22px),
        repeating-linear-gradient(189deg, rgb(20, 5, 20) 0px, rgb(20, 5, 20) 19px, transparent 19px, transparent 22px),
        repeating-linear-gradient(148deg, rgb(20, 5, 20) 0px, rgb(20, 5, 20) 19px, transparent 19px, transparent 22px),
        linear-gradient(90deg, rgb(255, 182, 193), rgb(255, 105, 180));
    }
    #canvas-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      inset: 0;
      z-index: 0;
      touch-action: none;
      width: 100vw;
      height: 100vh;
      min-width: 100%;
      min-height: 100%;
    }
    #canvas-container canvas {
      display: block;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    #affirmation {
      position: fixed;
      left: 50%;
      bottom: 22%;
      width: 100%;
      max-width: 92%;
      -webkit-transform: translateX(-50%);
      transform: translateX(-50%);
      z-index: 10;
      padding: 1.5rem 2rem;
      color: rgba(255, 255, 255, 0.98);
      font-size: clamp(1.1rem, 4.2vw, 1.5rem);
      font-weight: 400;
      text-align: center;
      line-height: 1.65;
      text-shadow: 0 0 20px var(--pink-bright), 0 0 40px var(--pink-deep);
      opacity: 0;
      pointer-events: none;
      -webkit-transition: opacity 0.9s ease;
      transition: opacity 0.9s ease;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    #affirmation.visible {
      opacity: 1;
      -webkit-animation: affirmation-in 0.8s ease, affirmation-glow 3s ease-in-out 0.5s infinite;
      animation: affirmation-in 0.8s ease, affirmation-glow 3s ease-in-out 0.5s infinite;
    }
    @-webkit-keyframes affirmation-in {
      from { -webkit-transform: translateX(-50%) translateY(12px); transform: translateX(-50%) translateY(12px); opacity: 0; }
      to { -webkit-transform: translateX(-50%) translateY(0); transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    @keyframes affirmation-in {
      from { transform: translateX(-50%) translateY(12px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    @-webkit-keyframes affirmation-glow {
      0%, 100% { text-shadow: 0 0 20px var(--pink-bright), 0 0 40px var(--pink-deep); }
      50% { text-shadow: 0 0 30px var(--pink-bright), 0 0 60px var(--pink-deep), 0 0 80px rgba(255, 105, 180, 0.3); }
    }
    @keyframes affirmation-glow {
      0%, 100% { text-shadow: 0 0 20px var(--pink-bright), 0 0 40px var(--pink-deep); }
      50% { text-shadow: 0 0 30px var(--pink-bright), 0 0 60px var(--pink-deep), 0 0 80px rgba(255, 105, 180, 0.3); }
    }
    /* Transition Overlay */
    #transition-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 100;
      background: radial-gradient(ellipse at center, var(--pink-bright), var(--pink-deep), var(--dark-color));
      opacity: 0;
      visibility: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 1s ease, visibility 1s ease;
    }
    #transition-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    #transition-overlay .message {
      color: white;
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: 300;
      text-align: center;
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      animation: float-up 1.5s ease-out;
    }
    @keyframes float-up {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .flower-icon {
      font-size: 5rem;
      margin-bottom: 1.5rem;
      animation: bloom 1.5s ease-out;
    }
    @keyframes bloom {
      0% { opacity: 0; transform: scale(0) rotate(-180deg); }
      100% { opacity: 1; transform: scale(1) rotate(0deg); }
    }
  </style>
</head>
<body>
  <div class="night-bg"></div>
  <div id="canvas-container"></div>
  <!-- Transition Overlay -->
  <div id="transition-overlay">
    <div class="flower-icon">ðŸŒ¸</div>
    <div class="message">A special surprise awaits...</div>
  </div>
  <div id="affirmation" aria-live="polite"></div>

  <script>
(function () {
  'use strict';

  // â€”â€”â€” Affirmations (longer, pang-palakas ng loob) â€”â€”â€”
  var AFFIRMATIONS = [
    'You are safe here. Let yourself feel it.',
    "It's okay to rest. Your body and mind deserve it.",
    'You deserve kindnessâ€”especially from yourself.',
    'Breathe. This moment is yours. Nothing else is required.',
    'You are enough, exactly as you are.',
    'Softness is allowed. You don\'t have to be strong all the time.',
    "Let go of what you don't need to carry. You've been holding it long enough.",
    'You are worthy of peace. It is not selfish to claim it.',
    'Take your time. Rushing is not a requirement.',
    'You are held. Even when it doesn\'t feel like it.',
    'Be gentle with yourself. You\'re doing the best you can.',
    'This too shall pass, gently. You will get through this.',
    'Your feelings are valid. They don\'t need to be justified.',
    'Rest is part of healing. Allow yourself to recover.',
    'You matter. Your presence in this world has meaning.'
  ];

  // â€”â€”â€” Pop Counter System â€”â€”â€”
  var REQUIRED_POPS = 5;
  var popCount = 0;
  var transitionTriggered = false;
  var transitionOverlay = document.getElementById('transition-overlay');

  function triggerFlowerTransition() {
    if (transitionTriggered) return;
    transitionTriggered = true;
    
    // Show transition overlay
    transitionOverlay.classList.add('visible');
    
    // Navigate to flower page after animation
    setTimeout(function() {
      window.location.href = '../flower/index.html';
    }, 2500);
  }

  function incrementPopCount() {
    if (popCount >= REQUIRED_POPS) return;
    popCount++;
    
    if (popCount >= REQUIRED_POPS) {
      setTimeout(triggerFlowerTransition, 800);
    }
  }

  // â€”â€”â€” Audio â€”â€”â€”
  var pianoAudio = null;
  var audioContext = null;
  var pianoStarted = false;

  function initPiano() {
    if (pianoAudio) return;
    pianoAudio = new Audio('audio/calm-classical-piano-291012.mp3');
    pianoAudio.loop = true;
    pianoAudio.volume = 0.35;
    pianoAudio.preload = 'auto';
  }

  function startPianoOnInteraction() {
    if (pianoStarted) return;
    pianoStarted = true;
    initPiano();
    if (pianoAudio) pianoAudio.play().catch(function () {});
  }

  function playChime() {
    try {
      if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
      var ctx = audioContext;
      var now = ctx.currentTime;
      var osc = ctx.createOscillator();
      var gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.type = 'sine';
      osc.frequency.setValueAtTime(784, now);
      osc.frequency.exponentialRampToValueAtTime(392, now + 0.5);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.06, now + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
      osc.start(now);
      osc.stop(now + 0.9);
    } catch (e) {}
  }

  // â€”â€”â€” UI â€”â€”â€”
  var affirmationEl = document.getElementById('affirmation');

  function showAffirmation(text) {
    affirmationEl.textContent = text;
    affirmationEl.classList.add('visible');
    clearTimeout(affirmationEl._hide);
    affirmationEl._hide = setTimeout(function () {
      affirmationEl.classList.remove('visible');
    }, 8000);
  }

  // Auto-start music on first interaction
  var musicStarted = false;
  function startMusicOnInteraction() {
    if (musicStarted) return;
    musicStarted = true;
    startPianoOnInteraction();
  }
  document.addEventListener('click', startMusicOnInteraction, { once: true });
  document.addEventListener('touchstart', startMusicOnInteraction, { once: true });

  // â€”â€”â€” WebGL support check â€”â€”â€”
  function webGLSupported() {
    try {
      var c = document.createElement('canvas');
      var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
      return !!gl;
    } catch (e) { return false; }
  }

  var container = document.getElementById('canvas-container');

  function getContainerSize() {
    var rect = container.getBoundingClientRect();
    return { w: Math.floor(rect.width), h: Math.floor(rect.height) };
  }

  function initWebGL() {
    try {
      var scene = new THREE.Scene();
      scene.background = null; // Transparent to show night-bg
      scene.fog = new THREE.FogExp2(0x1a0a1a, 0.03);

      var camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
      camera.position.set(0, 0, 12);
      camera.lookAt(0, 0, 0);

      var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      var size = getContainerSize();
      renderer.setSize(size.w, size.h);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.9;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

  // Soft lighting (warm pink)
  var ambient = new THREE.AmbientLight(0xff69b4, 0.4);
  scene.add(ambient);
  var point1 = new THREE.PointLight(0xff1493, 0.5, 30);
  point1.position.set(4, 4, 6);
  scene.add(point1);
  var point2 = new THREE.PointLight(0xffb6c1, 0.4, 25);
  point2.position.set(-5, -2, 5);
  scene.add(point2);

  // Petals â€” each has a unique message (no repeat until all shown)
  var petalGroup = new THREE.Group();
  scene.add(petalGroup);

  // Petal EXPLOSION burst effect - dramatic pop!
  var burstGroup = new THREE.Group();
  scene.add(burstGroup);
  var BURST_DURATION = 1.2;
  var HALO_DURATION = 0.8;
  
  function createBurstAt(point) {
    // Expanding shockwave ring
    var ringGeom = new THREE.RingGeometry(0.1, 0.4, 48);
    var haloMat = new THREE.MeshBasicMaterial({
      color: 0xff69b4,
      transparent: true,
      opacity: 1,
      side: THREE.DoubleSide
    });
    var halo = new THREE.Mesh(ringGeom, haloMat);
    halo.position.copy(point);
    halo.userData = { isHalo: true, life: 1 };
    burstGroup.add(halo);
    
    // Second inner ring for layered effect
    var ringGeom2 = new THREE.RingGeometry(0.05, 0.2, 32);
    var haloMat2 = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    var halo2 = new THREE.Mesh(ringGeom2, haloMat2);
    halo2.position.copy(point);
    halo2.userData = { isHalo: true, life: 1, isInner: true };
    burstGroup.add(halo2);
    
    // Petal fragment particles - more of them, varied sizes
    var colors = [0xffb6c1, 0xff69b4, 0xffc0cb, 0xff1493, 0xffe4e9, 0xffffff];
    
    // Large petal fragments - exploding outward
    for (var i = 0; i < 12; i++) {
      var angle = (i / 12) * Math.PI * 2 + Math.random() * 0.3;
      var speed = 3.5 + Math.random() * 2.5;
      var vx = Math.cos(angle) * speed;
      var vz = Math.sin(angle) * speed * 0.5;
      var vy = (Math.random() - 0.2) * 3;
      var particleGeom = new THREE.PlaneGeometry(0.3 + Math.random() * 0.2, 0.5 + Math.random() * 0.3);
      var mat = new THREE.MeshBasicMaterial({
        color: colors[i % colors.length],
        transparent: true,
        opacity: 1,
        side: THREE.DoubleSide
      });
      var mesh = new THREE.Mesh(particleGeom, mat);
      mesh.position.copy(point);
      mesh.rotation.z = Math.random() * Math.PI * 2;
      mesh.userData = { vx: vx, vy: vy, vz: vz, life: 1, spin: (Math.random() - 0.5) * 0.4, gravity: 0.08 };
      burstGroup.add(mesh);
    }
    
    // Small sparkle particles
    for (var j = 0; j < 20; j++) {
      var angle2 = Math.random() * Math.PI * 2;
      var speed2 = 2 + Math.random() * 4;
      var sparkGeom = new THREE.PlaneGeometry(0.1, 0.1);
      var sparkMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1,
        side: THREE.DoubleSide
      });
      var spark = new THREE.Mesh(sparkGeom, sparkMat);
      spark.position.copy(point);
      spark.userData = { 
        vx: Math.cos(angle2) * speed2, 
        vy: (Math.random() - 0.3) * speed2, 
        vz: Math.sin(angle2) * speed2 * 0.5, 
        life: 1,
        isSpark: true
      };
      burstGroup.add(spark);
    }
    
    // Glowing center flash
    var flashGeom = new THREE.CircleGeometry(0.8, 32);
    var flashMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide
    });
    var flash = new THREE.Mesh(flashGeom, flashMat);
    flash.position.copy(point);
    flash.userData = { isFlash: true, life: 1 };
    burstGroup.add(flash);
  }

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();

  var affirmationQueue = [];
  var queueIndex = 0;
  function buildAffirmationQueue() {
    for (var i = 0; i < AFFIRMATIONS.length; i++) affirmationQueue[i] = i;
    for (var j = affirmationQueue.length - 1; j > 0; j--) {
      var k = Math.floor(Math.random() * (j + 1));
      var tmp = affirmationQueue[j];
      affirmationQueue[j] = affirmationQueue[k];
      affirmationQueue[k] = tmp;
    }
    queueIndex = 0;
  }
  function nextAffirmationIndex() {
    var idx = affirmationQueue[queueIndex];
    queueIndex = (queueIndex + 1) % AFFIRMATIONS.length;
    if (queueIndex === 0) buildAffirmationQueue();
    return idx;
  }
  buildAffirmationQueue();

  // Enhanced 3D Petal Colors with gradient info
  var PETAL_COLOR_SETS = [
    { base: '#ffb6c1', highlight: '#ffe4e9', shadow: '#ff8da1', rim: '#ffffff' }, // Light pink
    { base: '#ff69b4', highlight: '#ff9ecf', shadow: '#e84593', rim: '#ffd1e8' }, // Hot pink
    { base: '#ffc0cb', highlight: '#ffe4ec', shadow: '#ff9bb3', rim: '#ffffff' }, // Pink
    { base: '#dda0dd', highlight: '#f0d0f0', shadow: '#ba55d3', rim: '#f8e8f8' }, // Plum
    { base: '#e8b4c8', highlight: '#f8dce8', shadow: '#d48ba8', rim: '#fff0f5' }, // Rose
    { base: '#f0b8d0', highlight: '#fce4ec', shadow: '#e080a0', rim: '#ffffff' }, // Blush
    { base: '#e6a8d7', highlight: '#f8d0ef', shadow: '#c060a0', rim: '#fce4f8' }, // Orchid
    { base: '#ffcce5', highlight: '#ffe8f2', shadow: '#ff99cc', rim: '#ffffff' }, // Candy pink
    { base: '#d4a5c9', highlight: '#f0d8eb', shadow: '#b070a0', rim: '#f8e8f4' }  // Mauve
  ];
  
  var petalGeometry = new THREE.PlaneGeometry(1, 1);
  
  // Create 3D-looking petal texture with gradients, highlights, and shadows
  function makePetalTexture3D(colorSet) {
    var size = 256; // Higher resolution for better quality
    var canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, size, size);
    
    ctx.save();
    ctx.translate(size / 2, size / 2);
    
    // Draw petal shape path
    function drawPetalPath() {
      ctx.beginPath();
      // More realistic petal shape with curves
      ctx.moveTo(0, -55);
      ctx.bezierCurveTo(45, -40, 50, 0, 45, 35);
      ctx.bezierCurveTo(35, 50, 10, 58, 0, 58);
      ctx.bezierCurveTo(-10, 58, -35, 50, -45, 35);
      ctx.bezierCurveTo(-50, 0, -45, -40, 0, -55);
      ctx.closePath();
    }
    
    // Layer 1: Base shadow (gives depth)
    ctx.save();
    ctx.translate(3, 4);
    drawPetalPath();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.fill();
    ctx.restore();
    
    // Layer 2: Main petal gradient (3D effect)
    drawPetalPath();
    var mainGrad = ctx.createRadialGradient(-15, -20, 0, 0, 10, 80);
    mainGrad.addColorStop(0, colorSet.highlight);
    mainGrad.addColorStop(0.3, colorSet.base);
    mainGrad.addColorStop(0.7, colorSet.base);
    mainGrad.addColorStop(1, colorSet.shadow);
    ctx.fillStyle = mainGrad;
    ctx.fill();
    
    // Layer 3: Highlight on top (light reflection)
    ctx.save();
    ctx.clip();
    var highlightGrad = ctx.createRadialGradient(-20, -30, 5, -15, -25, 40);
    highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
    highlightGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
    highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = highlightGrad;
    ctx.fillRect(-60, -60, 120, 120);
    ctx.restore();
    
    // Layer 4: Center vein (realistic detail)
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(0, -45);
    ctx.quadraticCurveTo(2, 0, 0, 50);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Side veins
    for (var i = 0; i < 4; i++) {
      var y = -30 + i * 20;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.quadraticCurveTo(15, y + 8, 25, y + 5);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.quadraticCurveTo(-15, y + 8, -25, y + 5);
      ctx.stroke();
    }
    ctx.restore();
    
    // Layer 5: Rim light (edge glow)
    drawPetalPath();
    ctx.strokeStyle = colorSet.rim;
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4;
    ctx.stroke();
    ctx.globalAlpha = 1;
    
    // Layer 6: Inner glow
    drawPetalPath();
    ctx.save();
    ctx.clip();
    var innerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 60);
    innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
    innerGlow.addColorStop(0.5, 'rgba(255, 200, 220, 0.05)');
    innerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = innerGlow;
    ctx.fill();
    ctx.restore();
    
    ctx.restore();
    
    var tex = new THREE.CanvasTexture(canvas);
    tex.needsUpdate = true;
    return tex;
  }
  
  var petalTextures = {};
  function getPetalTexture(colorSetIndex) {
    if (!petalTextures[colorSetIndex]) {
      petalTextures[colorSetIndex] = makePetalTexture3D(PETAL_COLOR_SETS[colorSetIndex]);
    }
    return petalTextures[colorSetIndex];
  }
  
  function createPetal() {
    var geometry = petalGeometry.clone();
    var colorIndex = Math.floor(Math.random() * PETAL_COLOR_SETS.length);
    var texture = getPetalTexture(colorIndex);
    var material = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.DoubleSide,
      transparent: true,
      alphaTest: 0.08,
      depthWrite: true
    });
    var mesh = new THREE.Mesh(geometry, material);
    var scale = 1.6 + Math.random() * 1.0;
    mesh.scale.set(scale, scale * 1.2, 1); // Slightly elongated for realism
    mesh.userData.baseScale = scale;
    mesh.userData.baseScaleY = scale * 1.2;
    mesh.position.set(
      (Math.random() - 0.5) * 20,
      (Math.random() - 0.5) * 16 + 3,
      (Math.random() - 0.5) * 8 - 2
    );
    // More natural 3D rotation
    mesh.rotation.z = Math.random() * Math.PI * 2;
    mesh.rotation.y = (Math.random() - 0.5) * Math.PI * 0.8;
    mesh.rotation.x = (Math.random() - 0.5) * 0.5;
    mesh.userData.speed = 0.018 + Math.random() * 0.014;
    mesh.userData.phase = Math.random() * Math.PI * 2;
    mesh.userData.sway = 0.02 + Math.random() * 0.018;
    mesh.userData.spin = (Math.random() - 0.5) * 0.025;
    mesh.userData.wobble = Math.random() * Math.PI * 2; // For 3D wobble effect
    mesh.userData.wobbleSpeed = 0.5 + Math.random() * 0.5;
    mesh.userData.fading = false;
    mesh.userData.scale = 1;
    mesh.userData.opacity = 1;
    mesh.userData.affirmationIndex = nextAffirmationIndex();
    petalGroup.add(mesh);
    return mesh;
  }

  var petalCount = 80;
  for (var i = 0; i < petalCount; i++) createPetal();

  var lastTapTime = 0;
  var TAP_COOLDOWN_MS = 350;
  function onPointerDown(event) {
    if (transitionTriggered) return; // Prevent interaction during transition
    if (event && event.clientX != null) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }
    if (Date.now() - lastTapTime < TAP_COOLDOWN_MS) return;
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(petalGroup.children, true);
    if (intersects.length === 0) return;
    var obj = intersects[0].object;
    if (!obj.userData || obj.userData.fading) return;
    lastTapTime = Date.now();
    obj.userData.fading = true;
    playChime();
    createBurstAt(intersects[0].point.clone());
    
    // Increment pop counter
    incrementPopCount();
    
    var msgIndex = obj.userData.affirmationIndex;
    if (typeof msgIndex === 'number' && AFFIRMATIONS[msgIndex]) {
      showAffirmation(AFFIRMATIONS[msgIndex]);
    }
  }

  function updateMouseFromEvent(e) {
    var x = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
    var y = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
    if (x !== undefined && y !== undefined) {
      mouse.x = (x / window.innerWidth) * 2 - 1;
      mouse.y = -(y / window.innerHeight) * 2 + 1;
    }
  }

  container.addEventListener('mousemove', updateMouseFromEvent);
  container.addEventListener('touchmove', function (e) {
    if (e.touches.length) updateMouseFromEvent(e);
  }, { passive: true });
  container.addEventListener('mousedown', function (e) {
    updateMouseFromEvent(e);
    onPointerDown(e);
  });
  container.addEventListener('touchstart', function (e) {
    if (e.touches.length) updateMouseFromEvent(e);
  }, { passive: true });
  container.addEventListener('touchend', function (e) {
    if (e.changedTouches && e.changedTouches[0]) {
      var t = e.changedTouches[0];
      mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
      onPointerDown({ clientX: t.clientX, clientY: t.clientY });
    }
    e.preventDefault();
  }, { passive: false });

  function resize() {
    var size = getContainerSize();
    camera.aspect = size.w / size.h;
    camera.updateProjectionMatrix();
    renderer.setSize(size.w, size.h);
  }
  window.addEventListener('resize', resize);
  resize();

  var clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    var dt = clock.getDelta();
    var t = clock.getElapsedTime();

    for (var i = petalGroup.children.length - 1; i >= 0; i--) {
      var mesh = petalGroup.children[i];
      var u = mesh.userData;
      if (!u) continue;

      if (u.fading) {
        u.opacity -= dt * 2.2;
        u.scale *= 0.88;
        var s = u.baseScale !== undefined ? u.baseScale : 1;
        var sy = u.baseScaleY !== undefined ? u.baseScaleY : s;
        mesh.scale.set(s * u.scale, sy * u.scale, 1);
        mesh.material.opacity = u.opacity;
        if (mesh.material.transparent === false) {
          mesh.material.transparent = true;
          mesh.material.depthWrite = false;
        }
        if (u.opacity <= 0) {
          petalGroup.remove(mesh);
          mesh.geometry.dispose();
          mesh.material.dispose();
          // Don't respawn - petal is permanently removed
        }
        continue;
      }

      // 3D movement with wobble for realistic floating
      mesh.position.y -= u.speed;
      mesh.position.x += Math.sin(t + u.phase) * u.sway;
      mesh.rotation.z += u.spin;
      
      // Add 3D wobble effect (makes petals look more natural/floating)
      if (u.wobble !== undefined) {
        var wobbleT = t * u.wobbleSpeed;
        mesh.rotation.x = Math.sin(wobbleT + u.wobble) * 0.3;
        mesh.rotation.y = Math.cos(wobbleT * 0.7 + u.wobble) * 0.4;
      }
      
      if (mesh.position.y < -10) {
        mesh.position.y = 8 + Math.random() * 4;
        mesh.position.x = (Math.random() - 0.5) * 22;
        mesh.position.z = (Math.random() - 0.5) * 10 - 3;
      }
    }

    for (var b = burstGroup.children.length - 1; b >= 0; b--) {
      var burstChild = burstGroup.children[b];
      var u = burstChild.userData;
      if (!u) continue;
      
      if (u.isHalo) {
        u.life -= dt / HALO_DURATION;
        var expandScale = u.isInner ? (1 + (1 - u.life) * 6) : (1 + (1 - u.life) * 8);
        burstChild.scale.setScalar(expandScale);
        burstChild.material.opacity = u.life * 0.9;
        if (u.life <= 0) {
          burstGroup.remove(burstChild);
          burstChild.geometry.dispose();
          burstChild.material.dispose();
        }
      } else if (u.isFlash) {
        u.life -= dt / 0.15; // Very fast flash
        burstChild.scale.setScalar(1 + (1 - u.life) * 2);
        burstChild.material.opacity = u.life;
        if (u.life <= 0) {
          burstGroup.remove(burstChild);
          burstChild.geometry.dispose();
          burstChild.material.dispose();
        }
      } else if (u.isSpark) {
        burstChild.position.x += u.vx * dt;
        burstChild.position.y += u.vy * dt;
        burstChild.position.z += u.vz * dt;
        u.life -= dt / 0.6; // Sparks fade faster
        burstChild.material.opacity = u.life;
        burstChild.scale.setScalar(u.life);
        if (u.life <= 0) {
          burstGroup.remove(burstChild);
          burstChild.geometry.dispose();
          burstChild.material.dispose();
        }
      } else {
        // Petal fragments with gravity
        burstChild.position.x += u.vx * dt;
        burstChild.position.y += u.vy * dt;
        burstChild.position.z += u.vz * dt;
        if (u.gravity) {
          u.vy -= u.gravity; // Apply gravity
        }
        if (u.spin) {
          burstChild.rotation.z += u.spin;
        }
        u.life -= dt / BURST_DURATION;
        burstChild.material.opacity = Math.max(0, u.life);
        burstChild.scale.multiplyScalar(0.98); // Shrink as they fly
        if (u.life <= 0) {
          burstGroup.remove(burstChild);
          burstChild.geometry.dispose();
          burstChild.material.dispose();
        }
      }
    }

    renderer.render(scene, camera);
  }
  animate();
      return true;
    } catch (e) { return false; }
  }

  // â€”â€”â€” 2D canvas fallback when WebGL is unavailable â€”â€”â€”
  function initFallback2D() {
    container.innerHTML = '';
    var canvas = document.createElement('canvas');
    var size = getContainerSize();
    canvas.width = size.w;
    canvas.height = size.h;
    canvas.style.display = 'block';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    container.appendChild(canvas);
    var ctx = canvas.getContext('2d');
    var w = canvas.width;
    var h = canvas.height;

    var fallbackQueue = [];
    var fallbackQueueIndex = 0;
    function buildQueue() {
      for (var i = 0; i < AFFIRMATIONS.length; i++) fallbackQueue[i] = i;
      for (var j = fallbackQueue.length - 1; j > 0; j--) {
        var k = Math.floor(Math.random() * (j + 1));
        var tmp = fallbackQueue[j];
        fallbackQueue[j] = fallbackQueue[k];
        fallbackQueue[k] = tmp;
      }
      fallbackQueueIndex = 0;
    }
    function nextIdx() {
      var idx = fallbackQueue[fallbackQueueIndex];
      fallbackQueueIndex = (fallbackQueueIndex + 1) % AFFIRMATIONS.length;
      if (fallbackQueueIndex === 0) buildQueue();
      return idx;
    }
    buildQueue();

    // Enhanced 2D Petal Colors with gradient info
    var PETAL_COLOR_SETS_2D = [
      { base: '#ffb6c1', highlight: '#ffe4e9', shadow: '#ff8da1' },
      { base: '#ff69b4', highlight: '#ff9ecf', shadow: '#e84593' },
      { base: '#ffc0cb', highlight: '#ffe4ec', shadow: '#ff9bb3' },
      { base: '#dda0dd', highlight: '#f0d0f0', shadow: '#ba55d3' },
      { base: '#e8b4c8', highlight: '#f8dce8', shadow: '#d48ba8' },
      { base: '#f0b8d0', highlight: '#fce4ec', shadow: '#e080a0' },
      { base: '#e6a8d7', highlight: '#f8d0ef', shadow: '#c060a0' },
      { base: '#ffcce5', highlight: '#ffe8f2', shadow: '#ff99cc' },
      { base: '#d4a5c9', highlight: '#f0d8eb', shadow: '#b070a0' }
    ];
    var petals = [];
    var petalCount = 80;
    var lastTapTime = 0;
    var TAP_COOLDOWN_MS = 350;
    var bursts = [];
    var BURST_DURATION_2D = 1.0;
    var HALO_DURATION_2D = 0.9;

    function createPetalData() {
      var baseScale = 20 + Math.random() * 16;
      var colorSet = PETAL_COLOR_SETS_2D[Math.floor(Math.random() * PETAL_COLOR_SETS_2D.length)];
      return {
        x: Math.random() * w,
        y: Math.random() * h,
        rotation: Math.random() * Math.PI * 2,
        speed: 0.5 + Math.random() * 0.35,
        phase: Math.random() * Math.PI * 2,
        sway: 0.8 + Math.random() * 0.5,
        spin: (Math.random() - 0.5) * 0.04,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.8 + Math.random() * 0.6,
        colorSet: colorSet,
        affirmationIndex: nextIdx(),
        fading: false,
        opacity: 1,
        scale: 1,
        baseScale: baseScale
      };
    }
    for (var i = 0; i < petalCount; i++) petals.push(createPetalData());

    // Draw 3D-looking petal with gradients
    function drawPetal(p, time) {
      var scale = (p.baseScale * p.scale) / 50;
      var wobbleX = Math.sin(time * p.wobbleSpeed + p.wobble) * 0.15;
      var wobbleY = Math.cos(time * p.wobbleSpeed * 0.7 + p.wobble) * 0.1;
      
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rotation);
      ctx.scale(scale * (1 + wobbleX), scale * 1.2 * (1 + wobbleY));
      ctx.globalAlpha = p.opacity;
      
      // Shadow layer
      ctx.save();
      ctx.translate(2, 3);
      ctx.beginPath();
      ctx.moveTo(0, -55);
      ctx.bezierCurveTo(45, -40, 50, 0, 45, 35);
      ctx.bezierCurveTo(35, 50, 10, 58, 0, 58);
      ctx.bezierCurveTo(-10, 58, -35, 50, -45, 35);
      ctx.bezierCurveTo(-50, 0, -45, -40, 0, -55);
      ctx.closePath();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
      ctx.fill();
      ctx.restore();
      
      // Main petal with gradient
      ctx.beginPath();
      ctx.moveTo(0, -55);
      ctx.bezierCurveTo(45, -40, 50, 0, 45, 35);
      ctx.bezierCurveTo(35, 50, 10, 58, 0, 58);
      ctx.bezierCurveTo(-10, 58, -35, 50, -45, 35);
      ctx.bezierCurveTo(-50, 0, -45, -40, 0, -55);
      ctx.closePath();
      
      var grad = ctx.createRadialGradient(-15, -20, 0, 0, 10, 70);
      grad.addColorStop(0, p.colorSet.highlight);
      grad.addColorStop(0.4, p.colorSet.base);
      grad.addColorStop(1, p.colorSet.shadow);
      ctx.fillStyle = grad;
      ctx.fill();
      
      // Highlight
      ctx.save();
      ctx.clip();
      var hlGrad = ctx.createRadialGradient(-18, -28, 3, -12, -22, 35);
      hlGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      hlGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
      hlGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = hlGrad;
      ctx.fillRect(-60, -60, 120, 120);
      ctx.restore();
      
      // Center vein
      ctx.beginPath();
      ctx.moveTo(0, -45);
      ctx.quadraticCurveTo(1.5, 0, 0, 50);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Rim light
      ctx.beginPath();
      ctx.moveTo(0, -55);
      ctx.bezierCurveTo(45, -40, 50, 0, 45, 35);
      ctx.bezierCurveTo(35, 50, 10, 58, 0, 58);
      ctx.bezierCurveTo(-10, 58, -35, 50, -45, 35);
      ctx.bezierCurveTo(-50, 0, -45, -40, 0, -55);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }

    function createBurst2D(cx, cy) {
      var particles = [];
      var colors = ['#ffb6c1', '#ff69b4', '#ffc0cb', '#ff1493', '#ffe4e9', '#ffffff'];
      
      // Large petal fragments
      for (var i = 0; i < 14; i++) {
        var angle = (i / 14) * Math.PI * 2 + Math.random() * 0.3;
        var speed = 120 + Math.random() * 80;
        particles.push({
          x: 0, y: 0,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: colors[i % colors.length],
          size: 8 + Math.random() * 6,
          life: 1,
          spin: (Math.random() - 0.5) * 0.3,
          rotation: Math.random() * Math.PI * 2,
          gravity: 150
        });
      }
      
      // Small sparkles
      for (var j = 0; j < 25; j++) {
        var angle2 = Math.random() * Math.PI * 2;
        var speed2 = 80 + Math.random() * 150;
        particles.push({
          x: 0, y: 0,
          vx: Math.cos(angle2) * speed2,
          vy: Math.sin(angle2) * speed2,
          color: '#ffffff',
          size: 2 + Math.random() * 3,
          life: 1,
          isSpark: true,
          fadeSpeed: 2.5
        });
      }
      
      bursts.push({
        x: cx, y: cy,
        particles: particles,
        haloRadius: 0,
        haloAlpha: 1,
        halo2Radius: 0,
        halo2Alpha: 0.8,
        flashAlpha: 1,
        flashRadius: 30,
        startTime: Date.now()
      });
    }

    function hitTest(canvasX, canvasY) {
      for (var i = petals.length - 1; i >= 0; i--) {
        var p = petals[i];
        if (p.fading) continue;
        var dx = canvasX - p.x;
        var dy = canvasY - p.y;
        var cos = Math.cos(-p.rotation);
        var sin = Math.sin(-p.rotation);
        var lx = dx * cos - dy * sin;
        var ly = dx * sin + dy * cos;
        var hh = p.baseScale * p.scale;
        var hw = 0.7 * hh;
        if ((lx * lx) / (hw * hw) + (ly * ly) / (hh * hh) <= 1) return p;
      }
      return null;
    }

    function onPointerDown(ev) {
      if (transitionTriggered) return; // Prevent interaction during transition
      var clientX = ev.clientX != null ? ev.clientX : (ev.touches && ev.touches[0] && ev.touches[0].clientX);
      var clientY = ev.clientY != null ? ev.clientY : (ev.touches && ev.touches[0] && ev.touches[0].clientY);
      if (clientX == null || clientY == null) return;
      var rect = canvas.getBoundingClientRect();
      var scaleX = canvas.width / rect.width;
      var scaleY = canvas.height / rect.height;
      var canvasX = (clientX - rect.left) * scaleX;
      var canvasY = (clientY - rect.top) * scaleY;
      if (Date.now() - lastTapTime < TAP_COOLDOWN_MS) return;
      var p = hitTest(canvasX, canvasY);
      if (!p) return;
      lastTapTime = Date.now();
      p.fading = true;
      playChime();
      createBurst2D(p.x, p.y);
      
      // Increment pop counter
      incrementPopCount();
      
      if (typeof p.affirmationIndex === 'number' && AFFIRMATIONS[p.affirmationIndex]) showAffirmation(AFFIRMATIONS[p.affirmationIndex]);
    }

    canvas.addEventListener('mousedown', function (e) { onPointerDown(e); });
    canvas.addEventListener('touchstart', function (e) {
      if (e.touches.length) onPointerDown(e.touches[0]);
    }, { passive: true });
    canvas.addEventListener('touchend', function (e) {
      if (e.changedTouches && e.changedTouches[0]) onPointerDown(e.changedTouches[0]);
    });

    var startTime = Date.now();
    function animate2D() {
      requestAnimationFrame(animate2D);
      var t = (Date.now() - startTime) / 1000;
      var dt = 1 / 60;

      var g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, '#0d1b2a');
      g.addColorStop(0.25, '#1a237e');
      g.addColorStop(0.5, '#0d47a1');
      g.addColorStop(0.75, '#1565c0');
      g.addColorStop(1, '#0d1b2a');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      for (var b = bursts.length - 1; b >= 0; b--) {
        var burst = bursts[b];
        var burstAge = (Date.now() - burst.startTime) / 1000;
        var haloLife = Math.max(0, 1 - burstAge / HALO_DURATION_2D);
        
        // Center flash
        if (burst.flashAlpha > 0) {
          burst.flashAlpha -= dt * 8;
          burst.flashRadius += dt * 200;
          ctx.save();
          ctx.globalAlpha = Math.max(0, burst.flashAlpha);
          var flashGrad = ctx.createRadialGradient(burst.x, burst.y, 0, burst.x, burst.y, burst.flashRadius);
          flashGrad.addColorStop(0, '#ffffff');
          flashGrad.addColorStop(0.5, '#ff69b4');
          flashGrad.addColorStop(1, 'transparent');
          ctx.fillStyle = flashGrad;
          ctx.beginPath();
          ctx.arc(burst.x, burst.y, burst.flashRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        // Outer shockwave ring
        burst.haloRadius = burstAge * 180;
        burst.haloAlpha = haloLife * 0.9;
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 105, 180, ' + burst.haloAlpha + ')';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, burst.haloRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // Inner ring
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 255, 255, ' + (burst.haloAlpha * 0.7) + ')';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(burst.x, burst.y, burst.haloRadius * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // Particles
        for (var j = burst.particles.length - 1; j >= 0; j--) {
          var pt = burst.particles[j];
          pt.x += pt.vx * dt;
          pt.y += pt.vy * dt;
          
          // Apply gravity to fragments
          if (pt.gravity) {
            pt.vy += pt.gravity * dt;
          }
          
          // Fade speed
          var fadeSpeed = pt.fadeSpeed || 1;
          pt.life -= dt * fadeSpeed / BURST_DURATION_2D;
          
          if (pt.life <= 0) continue;
          
          ctx.save();
          ctx.globalAlpha = Math.max(0, pt.life);
          ctx.fillStyle = pt.color;
          ctx.translate(burst.x + pt.x, burst.y + pt.y);
          
          if (pt.isSpark) {
            // Sparkles - small circles
            ctx.beginPath();
            ctx.arc(0, 0, pt.size * pt.life, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Petal fragments - rotating ellipses
            if (pt.spin) {
              pt.rotation += pt.spin;
            }
            ctx.rotate(pt.rotation || 0);
            ctx.beginPath();
            ctx.ellipse(0, 0, pt.size * 0.6, pt.size, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
        
        if (haloLife <= 0 && burst.flashAlpha <= 0) bursts.splice(b, 1);
      }

      for (var i = petals.length - 1; i >= 0; i--) {
        var p = petals[i];
        if (p.fading) {
          p.opacity -= dt * 2.2;
          p.scale *= 0.88;
          if (p.opacity <= 0) {
            petals.splice(i, 1);
            // Don't respawn - petal is permanently removed
          } else {
            drawPetal(p, t);
          }
          continue;
        }
        p.y += p.speed;
        p.x += Math.sin(t + p.phase) * p.sway;
        p.rotation += p.spin;
        if (p.y > h + 50) { p.y = -50; p.x = Math.random() * w; }
        if (p.y < -50) { p.y = h + 50; p.x = Math.random() * w; }
        if (p.x < -50) p.x = w + 50;
        if (p.x > w + 50) p.x = -50;
        drawPetal(p, t);
      }
    }
    animate2D();

    window.addEventListener('resize', function () {
      var size = getContainerSize();
      canvas.width = size.w;
      canvas.height = size.h;
      w = size.w;
      h = size.h;
    });
  }

  if (!webGLSupported() || !initWebGL()) initFallback2D();
})();
  </script>
</body>
</html>
